#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

#include "images/title.h"
#include "images/play.h"
#include "images/end.h"
#include "images/player.h"
#include "images/destination.h"
#include "images/lose.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3
  // Set video mode to Mode 3 and enable BG2 (background layer)
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Variables to handle input tracking
  // Save current and previous state of button input
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  enum gba_state state = START;
  int justEnteredPlay = 1;  // Used to only draw PLAY screen once per entry

  // Game objects: swatter (player) and destination (fly)
  Swatter swatter = {130, 110, 16, 16};
  int prevSwatterRow = swatter.row;
  int prevSwatterCol = swatter.col;

  Fly destObj = {30, 60, 16, 16, 1};

  int score = 0;
  int timeLeft = 30;
  vBlankCounter = 0;  // Used for timer control

  while (1) {
    previousButtons = currentButtons;
    currentButtons = BUTTONS;

    // RESET: Anytime SELECT is pressed, reset everything
    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
      state = START;
      score = 0;
      timeLeft = 30;
      vBlankCounter = 0;
      swatter.row = 130;
      swatter.col = 110;
      destObj.active = 1;
      justEnteredPlay = 0;
      drawFullScreenImageDMA(title);  // Show start screen
    }

    waitForVBlank();  // Avoid tearing by syncing drawing to VBlank

    switch (state) {
      case START:
        drawFullScreenImageDMA(title);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          justEnteredPlay = 1;  // Mark that we just entered PLAY
        }
        break;

      case PLAY:
        // Update timer every 60 vBlanks = ~1 second
        if (vBlankCounter % 60 == 0 && timeLeft > 0) {
        timeLeft--;
        }

        // drawFullScreenImageDMA(play);
        if (justEnteredPlay) {
          drawFullScreenImageDMA(play); // Draw background
          justEnteredPlay = 0;
        }

      // Save old position for undrawing
      prevSwatterRow = swatter.row;
      prevSwatterCol = swatter.col;

      // Swatter movement
      if (KEY_DOWN(BUTTON_UP, currentButtons)) swatter.row--;
      if (KEY_DOWN(BUTTON_DOWN, currentButtons)) swatter.row++;
      if (KEY_DOWN(BUTTON_LEFT, currentButtons)) swatter.col--;
      if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) swatter.col++;

      // Keep swatter within bounds
      if (swatter.row < 35) swatter.row = 35;
      if (swatter.row > HEIGHT - swatter.height) swatter.row = HEIGHT - swatter.height;
      if (swatter.col < 0) swatter.col = 0;
      if (swatter.col > WIDTH - swatter.width) swatter.col = WIDTH - swatter.width;

      // Draw fly
      if (destObj.active) {
        drawImageDMA(destObj.row, destObj.col, destObj.width, destObj.height, destination);
      }
      // Undraw old swatter and redraw new position
      undrawImageDMA(prevSwatterRow, prevSwatterCol, swatter.width, swatter.height, play);
      drawSwatter(swatter.row, swatter.col, swatter.width, swatter.height);

      // Check swat collision
      if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
        int swatHit = (swatter.row < destObj.row + destObj.height &&
                      swatter.row + swatter.height > destObj.row &&
                      swatter.col < destObj.col + destObj.width &&
                      swatter.col + swatter.width > destObj.col);

        if (swatHit && destObj.active) {
          score++;
          destObj.active = 0;
        }
        // Remove the fly (will be redrawn later)
        undrawImageDMA(destObj.row, destObj.col, destObj.width, destObj.height, play);
      }

      // Draw HUD: Time and Score
      drawString(5, 5, "Time:", WHITE);
      drawString(20, 5, "Score:", WHITE);

      // Draw dynamic numbers
      char numBuffer[10], scoreNum[10];
      sprintf(numBuffer, "%d", timeLeft);
      sprintf(scoreNum, "%d", score);

      // Erase number areas only
      undrawImageDMA(5, 60, 30, 10, play);
      undrawImageDMA(20, 60, 30, 10, play);

      // Draw updated numbers
      drawString(5, 60, numBuffer, WHITE);
      drawString(20, 60, scoreNum, WHITE);

      // Respawn fly randomly
      if (!destObj.active) {
        destObj.row = randint(35, HEIGHT - destObj.height);
        destObj.col = randint(10, WIDTH - destObj.width);
        destObj.active = 1;
      }

      // Win or lose condition
      if (score >= 5) {
        state = WIN;
      } else if (timeLeft <= 0) {
        state = LOSE;
      }

      break;

    case WIN:
      drawFullScreenImageDMA(end);
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
        state = START;

        justEnteredPlay = 0;

        drawFullScreenImageDMA(title);
      }
      break;
    case LOSE:
      drawFullScreenImageDMA(lose);
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
        state = START;

        justEnteredPlay = 0;

        drawFullScreenImageDMA(title);
      }
      break;
    }
    previousButtons = currentButtons;
  }
  return 0;
}
